*
*
*
*				1994.10.29		by Kuni.
*


*
*	ＶＤＰ関係はなんかぐちゃぐちゃになりかけてるので整理する必用あり
*
*

	.include	iocscall.equ
	.include	doscall.equ
	.include	gconst.h		* ラインルーチン用

	.xref	VideoRAM

	.xdef	read_vdp_0
	.xdef	read_vdp_1
	.xdef	read_vdp_2
	.xdef	read_vdp_3
	.xdef	write_vdp_0
	.xdef	write_vdp_1

*	.xdef	_vdp_init
*	.xdef	vram_adr
*	.xdef	FONT_adr
*	.xdef	_xorline
*	.xdef	_circlef
*	.xdef	_setcliprect

MFP_GPIP_6	equ	$000138		* 水平割り込みのベクタアドレス

gram		equ	$c00000

R09		equ	$e80012		* ＣＲＴＣレジスタ９
R21		equ	$e8002a
R23		equ	$e8002e
pla0		equ	$e00000

V_R02		equ	$e82600		* ビデオコントロールレジスタ２

*
*	ＭＳＸの画面モードと６８の画面モードの対応
*
*	ＭＳＸ			６８
*	screen0			16色	512*512
*	screen1			16色	512*512
*	screen2			16色	512*512
*	screen3			16色	512*512
*	screen4			16色	512*512
*	screen5			16色	512*512
*	screen6			16色	512*512
*	screen7			16色	512*512
*	screen8			256色	512*512
*	screen10		65536色	512*512
*	screen11		65536色	512*512
*	screen12		65536色	512*512
*
*

	.text
	.even


***************************************************************
*
*	ＶＤＰポートからの読み込みルーチン群
*
*    (返り値）
*	d0.b ・・・ 読み込んだ値
*
***************************************************************
read_vdp_0:				* ＶＲＡＭの読み込み
	movea.l	read_rot(pc),a0
	jmp	(a0)

read_vdp_1:				* ステータスレジスタの読みだし
	clr.w	d0
	move.b	R15,d0			* ステータスレジスタ番号の読みだし
	move.b	S0(pc,d0.w),d0
	rts

read_vdp_2:				* 書き込み専用ポート（読み込むと$ffが返るらしい）
read_vdp_3:
	moveq.b	#$ff,d0
	rts


***************************************************************
*
*	ＶＤＰポートへの書き込みルーチン群
*
*    (引数）
*	d0.b ・・・ 書き込む値
*
***************************************************************
write_vdp_0:				* VRAM への書き込み
	movea.l	write_rot(pc),a0
	jmp	(a0)

write_vdp_1:
	bchg.b	#0,w_ContReg_mode	* １バイト目か２バイト目か？
	bne	@f
	move.b	d0,first_bite		* １バイト目
	rts
@@:	move.b	d0,d1
	bmi	set_CReg_Direct		* コントロールレジスタの直接指定モード

	andi.b	#%01000000,d1
	beq	set_read_add
	move.l	w_vram_add,d1		* ＶＲＡＭライトアドレス設定
	andi.w	#%11000000_00000000,d1
	andi.w	#%00000000_00111111,d0
	move.b	d0,-(sp)
	move.w	(sp)+,d0
	move.b	first_bite,d0
	or.w	d0,d1
	move.l	d1,w_vram_add
	movea.l	set_w_gram_add_rot,a0
	jmp	(a0)

set_read_add:
	move.l	r_vram_add,d1		* ＶＲＡＭリードアドレス設定
	andi.w	#%11000000_00000000,d1
	andi.w	#%00000000_00111111,d0
	move.b	d0,-(sp)
	move.w	(sp)+,d0
	move.b	first_bite,d0
	or.w	d0,d1
	move.l	d1,r_vram_add
	movea.l	set_r_gram_add_rot,a0
	jmp	(a0)


***************************************************************
*
*	コントロールレジスタ書き込みルーチン
*
***************************************************************
set_CReg_Direct:
	move.b	first_bite,d1
	andi.w	#%00000000_00111111,d0
	move.w	d0,d2
	lsl.w	#1,d2
	move.w	w_CReg_jpt(pc,d2.w),d2
	jsr	w_CReg_jpt(pc,d2.w)
	rts


* 	サブルーチンへのコールテーブル
*	.d0.w	レジスタ番号		* <-- ワードであることに注意
*	.d1.b	書き込む値
w_CReg_jpt:
	.dc.w	normal			* R#0
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal			* R#10
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	w_R14
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal			* R#20
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal			* R#27
	.dc.w	noregister
	.dc.w	noregister
	.dc.w	noregister		* 30
	.dc.w	noregister
	.dc.w	normal			* R#32
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal			* R#40
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal
	.dc.w	normal			* R#46

normal:	lea.l	R0,a0
	move.b	d1,0(a0,d0.w)
	rts

noregister:				* 存在しないレジスターへの書き込み
	rts

w_R7:	clr.w	d0
	move.b	d1,d0
	lsr.w	#4,d0
	move.w	d0,text_color
	andi.w	#$000f,d1
	move.w	d1,back_color
	rts

w_R14:	swap	d1			* d1.l = 00000AAA_????????_????????
	clr.w	d1			* d1.l = 00000AAA_00000000_00000000
	lsr.l	#2,d1			* d1.l = 0000000A_AA000000_00000000 
	move.l	vram_add,d0
	andi.w	#%00111111_11111111,d0
	or.l	d0,d1
	bsr	set_VramAccessAdd
	rts


***************************************************************
*
*	ＧＲＡＭアドレス設定サブルーチン
*
*	d1.l	・・・ 対応するVRAMアドレス
*
***************************************************************
set_w_gram_add:
	move.l	d1,w_vram_add
	move.w	display_mode,d0
	lsl.w	#1,d0
	move.w	set_VAAdd_jpt(pc,d0.w),d0
	jsr	set_VAAdd_jpt(pc,d0.w)
	add.l	#$c00000,d0
	move.l	d0,w_gram_add
	rts

set_r_gram_add:
	move.l	d1,vram_add
	move.w	display_mode,d0
	lsl.w	#1,d0
	move.w	set_VAAdd_jpt(pc,d0.w),d0
	jsr	set_VAAdd_jpt(pc,d0.w)
	add.l	#$c00000,d0
	move.l	d0,r_gram_add
	rts
	

set_VAAdd_jpt:
	.dc.w	s_TEXT1			* text1
	.dc.w	s_TEXT2			* text2
	.dc.w	s_MULTICOLOR		* multi color
	.dc.w	s_GRAPHIC1		* graphic1
	.dc.w	s_GRAPHIC2		* graphic2
	.dc.w	s_GRAPHIC3		* graphic3
	.dc.w	s_GRAPHIC4		* graphic4
	.dc.w	s_GRAPHIC5		* graphic5
	.dc.w	s_GRAPHIC6		* graphic6
	.dc.w	s_GRAPHIC7		* graphic7
	.dc.w	s_SCREEN10		* SCREEN10
	.dc.w	s_SCREEN12		* SCREEN12

s_TEXT1:
	andi.l	#%00000011_11111111.d1		* 上位ワードも０にしたいから.lにしてある
	move.l	d1,d0
	divu.w	#40,d1
	move.w	d1,d0				* d0.l ・・商	y
	lsl.w	#8,d0				* d0.l = d0 * 256	(wordでＯＫ)
	lsl.l	#6,d0				* d0.l = d0 * 64 = y * 1024*16
	swap	d1				* d1.w ・・余り	x
	lsl.w	#3,d1
	move.w	d1,d2				* d2.w = x * 8
	add.w	d1,d1				* d1.w = x * 16
	add.w	d1,d2				* d2.w = x * 24

	add.w	d2,d0				* d0.l = アドレス (word 演算でＯＫ）
	rts

s_GRAPHIC4:
	lsl.l	#3,d1				* SCREEN 5 は,16色512*512モードを使う
	move.w	d1,d0
	andi.w	#%00000000_00000011_11111111,d1
	lsl.l	#1,d0				* 縦方向は一ラインおきになる
	andi.l	#%00011111_11111000_00000000,d0
	or.l	d1,d0
	rts


	

***************************************************************
*
*	ＶＲＡＭ読み込みルーチン
*
*	d0.b に読みこんだ値を入れて rts
*
***************************************************************
r_TEXT1:
r_GRAPHIC1:
r_GRAPHIC2:
r_MULTICOLOR:
	lea.l	VideoRAM,a0
	move.l	r_vram_add,d1
	move.b	0(a0,d1.l),d0
	move.w	d1,d2			* アドレスカウンタのインクリメント
	adqq.w	#1,d2			* TMS9918互換モードなので、A16〜A14は
	andi.w	#%00111111_11111111,d2	* インクリメントされない
	andi.w	#%11000000_00000000,d1	* ワードでＯＫ	
	or.w	d2,d1
	move.l	d1,r_vram_add
	rts

r_TEST2:
r_GRAPHIC3:
r_GRAPHIC5:
	lea.l	VideoRAM,a0
	move.l	r_vram_add,d0
	addq.l	#1,d0
	move.l	d0,r_vram_add
	move.b	-1(a0,d0.l),d0
	rts

r_GRAPHIC4:					* SCREEN 5
	movea.l	r_gram_add,a0
	move.w	(a0),d0				* d0 = 00000000_0000****
	lsl.w	#4,d0				* d0 = 00000000_****0000
	or.w	4(a0),d0			* d0 = 00000000_****&&&&

	lea.l	8(a0),a0
	move.l	r_vram_add,d1
	addq.l	#1,d1
	move.l	d1,r_vram_add
	andi.w	#%00000000_00000000_01111111,d1	* ライン境界をまたいだか
	bne	@f
	adda.l	#1024,a0			* 一ライン飛ばす
@@:	move.l	a0,r_gram_add
	rts

r_GRAPHIC7:					* SCREEN 8
	movea.l	r_gram_add,a0
	move.w	(a0),d0				* d0 = 00000000_********

	lea.l	8(a0),a0
	move.l	r_vram_add,d1
	addq.l	#1,d1
	move.l	d1,r_vram_add
	andi.w	#%00000000_00000000_11111111,d1	* ライン境界をまたいだか
	bne	@f
	adda.l	#1024,a0			* 一ライン飛ばす
@@:	move.l	a0,r_gram_add
	rts

***************************************************************
*
*	ＶＲＡＭ書き込みルーチン
*
*	d0.b に書き込む値を入れてコール
*
***************************************************************
w_TEXT1:
	movea.l	VideoRAM,a0
	move.l	w_vram_add,d1			* D1 ・・書き込むアドレス
	move.b	d0,0(a0,d1.l)			* VRAM へ書き込み
	andi.w	#%11111100_00000000,d1		* 下位１０ビットをクリア
	move.l	R#4,d2				* R#4 の値は使うことが多いから
	cmp.l	R#2,d1
	bne	@f
	move.l	d1,-(sp)
	bsr	w_p_name_tx1			* パターンネームテーブルへの書き込み
	move.l	(sp)+,d1
@@:	andi.w	#%11111000_00000000,d1
	cmp.l	d2,d1
	bne	@f
	bsr	w_p_gene_tx1			* パターンジェネレータテーブルへの書き込み
@@:	move.l	w_vram_add,d1
	move.w	d1,d2
	addq.w	#1,d2				* 上位ワードは変化しないからワードでＯＫ
	andi.w	#%00111111_11111111,d2
	andi.w	#%11000000_00000000,d1
	or.w	d2,d1
	move.l	d1,w_vram_add
	rts

w_p_gene_tx1:
*
*	更新フラグを立てて垂直帰線期間に一度に更新するようにする。
*
*	rewrite_f_all	.dc.l	0	rewrite_f_0〜8すべての or をとったもの
*	rewrite_f_0	.dc.l	0
*	rewrite_f_1	.dc.l	0
*	rewrite_f_2	.dc.l	0
*	rewrite_f_3	.dc.l	0
*	rewrite_f_4	.dc.l	0
*	rewrite_f_5	.dc.l	0
*	rewrite_f_6	.dc.l	0
*	rewrite_f_7	.dc.l	0
*	
	move.l	w_vram_add,d1
	andi.w	#%00000111_11111111,d1	
	lsr.w	#3,d1			* d1 ・・ 書き替えたキャラクター番号０〜２５５
	move.w	d1,d2
	andi.w	#%00000000_00011111,d2
	lsr.w	#5,d1
	move.l	rewrite0_f_0(pc,d1.w*4),d0	* rewrite0_f_n を読み込み
	bset.l	d2,d0
	move.l	d0,rewrite0_f_0(pc,d1.w*4)	* rewrite0_f_n へ書き込み
	rts	

*
*	文字キャラクタ表示
*
*	d0.l ・・・ キャラクタコード 0 〜 255
*
* (返り値)
*	d1,d2,d3,d4,a0 ・・・ 破壊
*	a1 ・・・・ 次に表示するＧＲＡＭアドレス
*
w_p_name_tx1:
	movea.l	w_gram_add,a1		* a1.l ・・・ 表示するＧＲＡＭアドレス
	lea.l	0(a0,d2.l),a0		* a0 = 実パターンネームテーブルアドレス

	lsl.w	#3,d0			* d0 *= 8
	adda.l	d0,a0			* a0 = 表示するフォントのアドレス

	move.w	text_color,d2		* ２ドット同時書き込みするため
	swap	d2
	move.w	text_color,d2
	move.w	back_color,d3
	swap	d3
	move.w	back_color,d3

	moveq.l	#4-1,d0			* ループカウンタ
loop1_put_char:
	move.w	(a0)+,d1		* d1 = フォントデータ


	moveq.l	#6-1,d4			* ループカウンタ
loop2_put_char:
	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	not0_1			* 最上位ビットが１でなければ次へ	
	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+
	bra	next0_1
not0_1:	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
next0_1:
	subq.w	#1,d4
	bne	loop2_put_char

	adda.l	#1024+1024-24,a1	* １ライン下げる
	lsl.w	#2,d1

	moveq.l	#6,d4			* ループカウンタ
loop3_put_char:
	lsl.w	#1,d1			* 最上位ビットを送り出す
	bcc	not0_2			* 最上位ビットが１でなければ次へ	
	move.l	d2,1024(a1)		* 前景色を表示
	move.l	d2,(a1)+
	bra	next0_2
not0_2:	move.l	d3,1024(a1)		* 背景色を表示
	move.l	d3,(a1)+		* 背景色を表示
next0_2:
	dbra	d4,loop3_put_char

	adda.l	#1024+1024-24,a1	* １ライン下げる

	dbra	d0,loop1_put_char

	suba.l	#1024*16-24,a1		* w_gram_add の更新
	move.l	a1,w_gram_add

	rts






*	------ ＶＤＰ Ｒｅｇｉｓｔｅｒｓ ------
*	コントロールレジスタ
R0:	.dc.b	0		* Mode register 0
R1:	.dc.b	0		* Mode register 1
	.dc.b	0
	.dc.b	0
	.dc.b	0
	.dc.b	0
	.dc.b	0
	.dc.b	0
R8:	.dc.b	0		* Mode register 2
R9:	.dc.b	0		* Mode register 3
R10:	.dc.b	0		* >> R#3
R11:	.dc.b	0		* >> R#5
R12:	.dc.b	0		* Text color / Back color register (ブリンクで使用）
R13:	.dc.b	0
R14:	.dc.b	0		* >> vram_add
R15:	.dc.b	0
R16:	.dc.b	0
R17:	.dc.b	0
R18:	.dc.b	0
R19:	.dc.b	0
R20:	.dc.b	0
R21:	.dc.b	0
R22:	.dc.b	0
R23:	.dc.b	0
R24:	.dc.b	0
R25:	.dc.b	0
R26:	.dc.b	0
R27:	.dc.b	0
	.dc.b	0		* dummy
	.dc.b	0		* dummy
	.dc.b	0		* dummy
	.dc.b	0		* dummy
R32:	.dc.b	0
R33:	.dc.b	0
R34:	.dc.b	0
R35:	.dc.b	0
R36:	.dc.b	0
R37:	.dc.b	0
R38:	.dc.b	0
R39:	.dc.b	0
R40:	.dc.b	0
R41:	.dc.b	0
R42:	.dc.b	0
R43:	.dc.b	0
R44:	.dc.b	0
R45:	.dc.b	0
R46:	.dc.b	0

*	ステータスレジスタ
S0:	.dc.b	0
S1:	.dc.b	0
S2:	.dc.b	0
S3:	.dc.b	0
S4:	.dc.b	0
S5:	.dc.b	0
S6:	.dc.b	0
S7:	.dc.b	0
S8:	.dc.b	0
S9:	.dc.b	0

	.even

*	パレットレジスタ
*		%0000_0GGG_0RRR_0BBB
P0:	.dc.w	%0000_0000_0000_0000
P1:	.dc.w	%0000_0000_0000_0000
P2:	.dc.w	%0000_0110_0001_0001
P3:	.dc.w	%0000_0111_0011_0011
P4:	.dc.w	%0000_0001_0001_0111
P5:	.dc.w	%0000_0011_0010_0111
P6:	.dc.w	%0000_0001_0101_0001
P7:	.dc.w	%0000_0110_0010_0111
P8:	.dc.w	%0000_0001_0111_0001
P9:	.dc.w	%0000_0011_0111_0011
P10:	.dc.w	%0000_0110_0110_0001
P11:	.dc.w	%0000_0110_0110_0100
P12:	.dc.w	%0000_0100_0001_0001
P13:	.dc.w	%0000_0010_0110_0101
P14:	.dc.w	%0000_0101_0101_0101
P15:	.dc.w	%0000_0111_0111_0111

*	特殊コントロールレジスタ
R2:	.dc.l	0		* Pattern name table base address
R3:	.dc.l	0		* Color table base address
R4:	.dc.l	0		* Pattern generator table base address
R5:	.dc.l	0		* Sprite attribute table bse address
R6:	.dc.l	0		* Sprite pattern generator table base address
*R7:				  Text color / Back drop color register
testcolor:			* 文字の色
	.dc.w	0
backcolor:			* 背景の色
	.dc.w	0


*	ＶＲＡＭアクセスアドレス
w_vram_add:			* 書き込み用
	.dc.l	0
w_gram_add:
	.dc.l	$C00000		* gramのw_vram_addに対応するアドレス
				* 

r_vram_add:			* 読み込み用
	.dc.l	0
r_gram_add:
	.dc.l	$C00000		* gramのr_vram_addに対応するアドレス
				* 画面モードによって使われ方が違う

*	現在の画面モード
display_mode:
	.dc.w			* 0 ・・・ text1
				* 1 ・・・ text2
				* 2 ・・・ multi color
				* 3 ・・・ graphic1
				* 4 ・・・ graphic2
				* 5 ・・・ graphic3
				* 6 ・・・ graphic4
				* 7 ・・・ graphic5
				* 8 ・・・ graphic6
				* 9 ・・・ graphic7
				*10 ・・・ SCREEN10
				*11 ・・・ SCREEN12

***************************************************************
*
*	ＶＤＰ初期設定（メモリ確保など）
*
*	(void *)vdp_init( char *filename);
*
***************************************************************
_vdp_init:
	link	a6,#0
	movem.l	a0-a2,-(sp)


*	Ｆｏｎｔ  Ｌｏａｄ
*		Ｆｏｎｔデータをファイルから読み込むルーチン
*
*	 メモリーを確保
*
	move.l	#$800,-(sp)	* 確保するメモリの大きさ
	DOS	_MALLOC
	addq.l	#4,sp
	tst.l	d0
	bmi	error
	move.l	d0,FONT_adr	* 確保したメモリの先頭アドレスを保存
	movea.l	d0,a2

*	フォントデータファイルをオープン＆リード

	movea.l	$8(a6),a1		*a1 = ファイルネームへのポインタ
	move.w	#0,-(sp)
	pea	(a1)
	DOS	_OPEN
	addq.l	#6,sp

	move.l	d0,-(sp)

	move.l	#2048,-(sp)		* 読み込むバイト数
	pea	(a2)			* 確保したメモリアドレスへのポインタ
	move.w	d0,-(sp)		* ファイルハンドルを設定
	DOS	_READ
	lea	10(sp),sp

	move.l	(sp)+,d0
	move.w	d0,-(sp)
	DOS	_CLOSE
	lea.l	2(sp),sp

*	movea.l	#FONT_adr,a1
*	movea.l	#FONT8x8,a0	* フォントのあるロムアドレス
*	move.w	#$80,d0		* １６バイト同時転送
*loop_vini:
*	move.l	(a0)+,(a1)+
*	move.l	(a0)+,(a1)+
*	move.l	(a0)+,(a1)+
*	move.l	(a0)+,(a1)+
*	subq.w	#1,d0
*	bne	loop_vini

	adda.l	#2048-8,a2
	move.l	#$fefefefe,d0	* カーソルの形を定義
	move.l	d0,(a2)+
	move.l	d0,(a2)+

*
*	ＶＲＡＭの確保
*
	move.l	#16*1024,-(sp)		* 確保するメモリの大きさ(VRAM 16K)をセット
	DOS	_MALLOC			* 
	addq.l	#4,sp
	tst.l	d0
	bmi	error

	move.l	d0,vram_adr		* 関数の返り値としてＤ０の中身が渡る。

	movem.l	(sp)+,a0-a2
	unlk	a6

	rts

vram_adr:
	.dc.l	0			* 確保したＶＲＡＭ１２８Ｋの先頭アドレスが入る

FONT_adr:
	.dc.l	0		* フォントのあるアドレス

error:
	pea	errms
	DOS	_PRINT
	addq.l	#4,sp

	movem.l	(sp)+,a0-a2
	unlk	a6

	DOS	_EXIT

errms:
	.dc.b	"メモリが確保できません"
	.dc.b	0

	.even

***************************************************************
*
*	線分描画（整数化Bresenham＋両端描画）
*
*
***************************************************************

	.offset	0	*glineの引数構造
*
*X0:	.ds.w	1	*始点座標
*Y0:	.ds.w	1	*
*X1:	.ds.w	1	*終点座標
*Y1:	.ds.w	1	*
*COL:	.ds.w	1	*描画色
*
	.text
	.even
*
_xorline:
ARGPTR	=	4+8*4+6*4
	movem.l	d0-d7/a0-a5,-(sp)

	bsr	set_apage

	movea.l	ARGPTR(sp),a5	*a5 = 引数列
	movem.w	(a5)+,d0-d3	*d0〜d3に座標を取り出す

 	cmp.w	d2,d0		*x0≦x1を保証する
	ble	gline0		*
	exg.l	d0,d2		*
	exg.l	d1,d3		*

gline0:	move.w	d1,d6		*始点/終点のG-RAMアドレスを求める
	move.w	d3,d7		*
	ext.l	d6		*
	ext.l	d7		*
				*
	moveq.l	#GSFTCTR,d4	*
	asl.l	d4,d6		*
	asl.l	d4,d7		*
	add.w	d0,d6		*
	add.w	d0,d6		*
	add.w	d2,d7		*
	add.w	d2,d7		*
				*
	movea.l	gbase,a0	*
	movea.l	a0,a2		*
	add.l	d6,a0		*a0 = 始点のG-RAMアドレス
	add.l	d7,a2		*a2 = 終点のG-RAMアドレス

	move.w	#GNBYTE,d5	*d5 = 横1ライン分のバイト数
	sub.w	d1,d3		*d3 = y1-y0
	beq	hor_line	*y0＝y1なら水平線
	bpl	gline1
	neg.w	d3
	neg.w	d5
gline1:	sub.w	d0,d2		*d2 = x1-x0 ( >=0 )
	beq	ver_line	*x0＝x1なら垂直線
*この時点で
*	d2 = dx = abs(x1-x0) ( > 0 )
*	d3 = dy = abs(y1-y0) ( > 0 )
*	d5 = sy = sgn(y1-y0) ( -1 or 1 )
*	（ただしd5はGNBYTE倍済み）

	move.w	(a5),d0		*d0 = 描画色

	cmp.w	d3,d2		*dy＞dxならば
	bcs	yline		*　yについてループ
	beq	xyline		*dy＝dxならば45度の線

			*dx≧dyのとき
xline:	move.w	d2,d1		*d1 = dx
	neg.w	d1		*d1 = e = -dx
	move.w	d2,d6		*d6 = n = dx
	add.w	d2,d2		*d2 = 2*dx
	add.w	d3,d3		*d3 = 2*dy
	subq.w	#1,d6		*dbraの動作を計算に入れて
	lsr.w	#1,d6		*　ループカウンタを半減
	scs.b	d4		*奇数ピクセルのとき非0
	addq.l	#2,a2		*プリデクリメントする分補正
				*do {
xline0:	eor.w	d0,(a0)+	*  pset(x++,y)
	eor.w	d0,-(a2)	*  pset(--x',y')
	add.w	d3,d1		*  e += 2*dy
	bmi	xline1		*  if (e >= 0) {
	adda.w	d5,a0		*    y += sy
	suba.w	d5,a2		*    y'-= sy
	sub.w	d2,d1		*    e -= 2*dx
				*  }
xline1:	dbra	d6,xline0	*} while (--n >= 0)

	tst.b	d4		*奇数ピクセル？
	beq	done		*　そうじゃない
	bra	odd		*中央のピクセルを点灯

			*dx＜dyのとき
yline:	move.w	d3,d1		*d1 = dy
	neg.w	d1		*d1 = e = -dy
	move.w	d3,d6		*d6 = n = dy
	add.w	d2,d2		*d2 = 2*dx
	add.w	d3,d3		*d3 = 2*dy
	subq.w	#1,d6		*dbraのことを計算に入れて
	lsr.w	#1,d6		*　ループカウンタを半減
	scs.b	d4		*奇数ピクセルのとき非0
	move.w	d5,d7		*d7 = d5 + 2
	addq.w	#2,d7		*
				*do {
yline0:	add.w	d2,d1		*  e += 2*dx
	bpl	yline1		*  if (e < 0) {
	eor.w	d0,(a0)		*    pset(x,y)
	adda.w	d5,a0		*    y += sy
	eor.w	d0,(a2)		*    pset(x',y')
	suba.w	d5,a2		*    y'-= sy
				*  }
	dbra	d6,yline0
	bra	done0
				*  else {
yline1:	eor.w	d0,(a0)+	*    pset(x++,y)
	adda.w	d5,a0		*    y += sy
	eor.w	d0,(a2)		*    pset(x',y')
	suba.w	d7,a2		*    x'--, y'-= sy
	sub.w	d3,d1		*    e -= 2*dy
				*  }
	dbra	d6,yline0	*} while (--n >= 0)

done0:	tst.b	d4		*奇数ピクセル？
	beq	done		*　そうじゃない
odd:	eor.w	d0,(a0)		*中央のピクセルを点灯

done:	movem.l	(sp)+,d0-d7/a0-a5
	rts
*
hor_line:		*水平線分
	sub.w	d0,d2		*d2 = dx = x1-x0
	move.w	(a5),d0		*d0 = 描画色
hloop:	eor.w	d0,(a0)+	*pset(x++,y)
	dbra	d2,hloop
	bra	done

xyline:			*45度の線分
	addq.w	#2,d5		*d5 = 2±GNBYTE
ver_line:		*垂直線分
	move.w	(a5),d0		*d0 = 描画色
vloop:	eor.w	d0,(a0)		*pset(x,y)
	adda.w	d5,a0		*y += sx
	dbra	d3,vloop	*dy+1回繰り返す
	bra	done


*******************************************************************
*
*		楕円を描く
*
*******************************************************************

PSET	macro	X,Y,COL,ADR	*クリッピングしつつ
	local	skip		*　点を打つマクロ
	movea.l	a4,a5		*
	cmp.l	(a5)+,X		*
	blt	skip		*
	cmp.l	(a5)+,Y		*
	blt	skip		*
	cmp.l	(a5)+,X		*
	bgt	skip		*
	cmp.l	(a5)+,Y		*
	bgt	skip		*
	move.w	COL,ADR		*
skip:				*
	.endm			*

PSET2	macro	X,Y,COL,ADR	*クリッピングしつつ
	local	skip		*　点を打つ(xor)マクロ
	movea.l	a4,a5		*
	cmp.l	(a5)+,X		*
	blt	skip		*
	cmp.l	(a5)+,Y		*
	blt	skip		*
	cmp.l	(a5)+,X		*
	bgt	skip		*
	cmp.l	(a5)+,Y		*
	bgt	skip		*
	eor.w	COL,ADR		*
skip:				*
	.endm			*
*
	.offset	0	*govalの引数構造
*
X0:	.ds.w	1	*中心座標
Y0:	.ds.w	1	*
XR:	.ds.w	1	*水平方向半径
YR:	.ds.w	1	*垂直方向半径
COL:	.ds.w	1	*描画色
xor:	.ds.w	1	*xor フラグ
*
	.offset	0	*クリッピング領域
*
LMINX:	.ds.l	1
LMINY:	.ds.l	1
LMAXX:	.ds.l	1
LMAXY:	.ds.l	1
LRECT:
*
	.offset	-58	*ワーク
*
WORKTOP:
X1:	.ds.w	1	*第１八分円x座標
Y1:	.ds.w	1	*第１八分円y座標
X2:	.ds.w	1	*第２八分円x座標
Y2:	.ds.w	1	*第２八分円y座標
EX1:	.ds.l	1	*x縮小誤差項1
EY1:	.ds.l	1	*y縮小誤差項1
EX2:	.ds.l	1	*x縮小誤差項2
EY2:	.ds.l	1	*y縮小誤差項2
EXDX:	.ds.l	1	*x縮小誤差項補正値
EXDY:	.ds.l	1	*x縮小誤差項増分
EYDX:	.ds.l	1	*y縮小誤差項補正値
EYDY:	.ds.l	1	*y縮小誤差項増分
CRECT:	.ds.b	LRECT	*シフトしたウィンドウ
xorf:	.ds.w	1	*フラグ避難場所
*
	.text
	.even
*
_circlef:
ARGPTR	=	8
	link	a6,#WORKTOP
	movem.l	d0-d7/a0-a5,-(sp)

	bsr	set_apage

	movea.l	ARGPTR(a6),a1	*a1 = 引数列

	movem.w	(a1),d0-d5	*(d0,d1) = (x0,y0) = 中心座標
				*d2 = XR = 水平方向半径
				*d3 = YR = 垂直方向半径
				*d4 = 描画色
				*d5 = xorf

	tst.w	d2		*XR＜0ならば
	bmi	done2		*  エラー終了
	tst.w	d3		*YR＜0ならば
	bmi	done2		*  エラー終了

	move.w	d5,xorf(a6)	*
	move.w	d4,d7		*

	lea.l	CRECT(a6),a4	*(x0,y0)が原点になるよう
	lea.l	cliprect,a5	*  クリッピング領域を
				*  平行移動する

	moveq.l	#2-1,d6		*
rloop:	moveq.l	#0,d5		*
	move.w	(a5)+,d5	*
	sub.l	d0,d5		*
	move.l	d5,(a4)+	*
				*
	moveq.l	#0,d5		*
	move.w	(a5)+,d5	*
	sub.l	d1,d5		*
	move.l	d5,(a4)+	*
				*
	dbra	d6,rloop	*
				*
	lea.l	-LRECT(a4),a4	*a4 = シフト後のクリッピング領域

	jsr	gramadr		*a0 = (x0,y0)のG-RAMアドレス

*********以下　座標値はすべて(-x0,-y0)のゲタ履き表現*********

	move.l	d3,d0		*a2 = (0,YR)のG-RAMアドレス
	moveq.l	#GSFTCTR,d6	*
	lsl.l	d6,d0		*
	lea.l	0(a0,d0.l),a2	*
	neg.l	d0		*a3 = (0,-YR)のG-RAMアドレス
	lea.l	0(a0,d0.l),a3	*

	move.l	d3,X2(a6)	*(x2,y2) = (0,YR)
	swap.w	d2
	move.l	d2,X1(a6)	*(x1,y1) = (XR,0)
	swap.w	d2

	move.l	d2,d0		*x縮小誤差項の
	neg.l	d0		*　仮初期化
	move.l	d0,EX1(a6)	*

	move.l	d3,d0		*y縮小誤差項の
	neg.l	d0		*　仮初期化
	move.l	d0,EY1(a6)	*

	add.w	d2,d2		*d2 = 2XR
	add.w	d3,d3		*d3 = 2YR
	subq.l	#2,d2		*d2 = 2(XR-1)
	subq.l	#2,d3		*d3 = 2(YR-1)
	move.l	d3,EXDX(a6)	*x縮小誤差項補正値
	move.l	d2,EXDY(a6)	*x縮小誤差項増分
	move.l	d2,EYDX(a6)	*y縮小誤差項補正値
	move.l	d3,EYDY(a6)	*y縮小誤差項増分
	addq.l	#2,d2		*d2 = 2XR
	addq.l	#2,d3		*d3 = 2XR

	adda.l	d2,a0		*a0 = a1 = (x1,y1)のG-RAMアドレス
	movea.l	a0,a1		*

	move.l	d2,d5		*d5 = 2XR
	add.l	d5,d5		*d5 = -4XR = (x1,y1)と(-x1,y1)との
	neg.l	d5		*	アドレスの差
	moveq.l	#0,d6		*d6 =    0 =(x2,y2)と(-x2,y2)との
				*	アドレスの差

	cmp.w	d3,d2		*2XRと2YRの大きい方を
	bcc	init1		*　d2に残す
	move.w	d3,d2		*d2 = max(2XR,2YR) = 2R

init0:	move.l	d6,EY1(a6)	*縦長楕円だから
	move.l	d6,EYDX(a6)	*　yは縮小しない
	move.l	d6,EYDY(a6)	*
	bra	init2

init1:	move.l	d6,EX1(a6)	*横長楕円だから
	move.l	d6,EXDX(a6)	*　xは縮小しない
	move.l	d6,EXDY(a6)	*

init2:	move.l	d2,d4		*d4 = -2R+1 = F-2
	neg.l	d4		*
	addq.l	#1,d4		*

	add.l	d2,d2		*d2 = 4x = 4R
	moveq.l	#0,d3		*d3 = 4y = 0

	move.l	EX1(a6),EX2(a6)	*x縮小誤差項2を初期化
	move.l	EY1(a6),EY2(a6)	*y縮小誤差項2を初期化

loop2:
P0	reg	(a0)		*    -x1-x2  x2 x1
P1	reg	(a1)		*-y2	 P7  P3
P2	reg	(a2)		*-y1  P5	P1
P3	reg	(a3)		*
P4	reg	0(a0,d5.l)	*
P5	reg	0(a1,d5.l)	* y1  P4	P0
P6	reg	0(a2,d6.l)	* y2	 P6  P2
P7	reg	0(a3,d6.l)	*

	move.w	xorf(a6),d0
	cmpi.w	#0,d0
	bne	do_xor

	movem.w	X1(a6),d0-d1
	PSET	d0,d1,d7,P0	*P0(x1,y1)
	neg.l	d1
	PSET	d0,d1,d7,P1	*P1(x1,-y1)
	neg.l	d0
	PSET	d0,d1,d7,P5	*P5(-x1,-y1)
	neg.l	d1
	PSET	d0,d1,d7,P4	*P4(-x1,y1)
	movem.w	X2(a6),d0-d1
	PSET	d0,d1,d7,P2	*P2(x2,y2)
	neg.l	d1
	PSET	d0,d1,d7,P3	*P3(x2,-y2)
	neg.l	d0
	PSET	d0,d1,d7,P7	*P7(-x2,-y2)
	neg.l	d1
	PSET	d0,d1,d7,P6	*P6(-x2,y2)

	bra	go

do_xor:
	movem.w	X1(a6),d0-d1
	PSET2	d0,d1,d7,P0	*P0(x1,y1)
	neg.l	d1
	PSET2	d0,d1,d7,P1	*P1(x1,-y1)
	neg.l	d0
	PSET2	d0,d1,d7,P5	*P5(-x1,-y1)
	neg.l	d1
	PSET2	d0,d1,d7,P4	*P4(-x1,y1)

	movem.w	X2(a6),d0-d1
	PSET2	d0,d1,d7,P2	*P2(x2,y2)
	neg.l	d1
	PSET2	d0,d1,d7,P3	*P3(x2,-y2)
	neg.l	d0
	PSET2	d0,d1,d7,P7	*P7(-x2,-y2)
	neg.l	d1
	PSET2	d0,d1,d7,P6	*P6(-x2,y2)

go:
	add.l	d3,d4		*F+=4y+2
	addq.l	#2,d4		*
	bmi	vmove		*F＜0ならば垂直移動

dmove:			*斜め移動
	subq.l	#4,d2		*4x
	sub.l	d2,d4		*F -= 4x

xcalc1:	move.l	EX1(a6),d0	*縮小を考慮して
	add.l	EXDY(a6),d0	*　x1を更新する
	bmi	xskip1		*
				*
	subq.w	#1,X1(a6)	*x1--
	subq.l	#2,a0		*P0を左へ移動
	subq.l	#2,a1		*P1を左へ移動
	addq.l	#4,d5		*P4をP0に近付ける
				*
	sub.l	EXDX(a6),d0	*
				*
xskip1:	move.l	d0,EX1(a6)	*

ycalc1:	move.l	EY2(a6),d0	*縮小を考慮して
	add.l	EYDY(a6),d0	*　y2を更新する
	bmi	yskip1		*
				*
	subq.w	#1,Y2(a6)	*y2--
	lea.l	-GNBYTE(a2),a2	*P2を上へ移動
	lea.l	GNBYTE(a3),a3	*P3を下へ移動
				*
	sub.l	EYDX(a6),d0	*
				*
yskip1:	move.l	d0,EY2(a6)	*

vmove:			*垂直移動
	addq.l	#4,d3		*4y

ycalc2:	move.l	EY1(a6),d0	*縮小を考慮して
	add.l	EYDY(a6),d0	*　y1を更新する
	bmi	yskip2		*
				*
	addq.w	#1,Y1(a6)	*y1++
	lea.l	GNBYTE(a0),a0	*P0を下へ移動
	lea.l	-GNBYTE(a1),a1	*P1を上へ移動
				*
	sub.l	EYDX(a6),d0	*
				*
yskip2:	move.l	d0,EY1(a6)	*

xcalc2:	move.l	EX2(a6),d0	*縮小を考慮して
	add.l	EXDY(a6),d0	*　x2を更新する
	bmi	xskip2		*
				*
	addq.w	#1,X2(a6)	*x2++
	addq.l	#2,a2		*P2を右へ移動
	addq.l	#2,a3		*P3を右へ移動
	subq.l	#4,d6		*P6をP2から遠ざける
				*
	sub.l	EXDX(a6),d0	*
				*
xskip2:	move.l	d0,EX2(a6)	*

	cmp.l	d3,d2		*4x≧4yのあいだ
	bge	loop2		*　繰り返す

done2:	movem.l	(sp)+,d0-d7/a0-a5
	unlk	a6
	rts

*
*	G-RAMアドレス関連モジュール
*

*******************************************************************
*
*	座標からG-RAMアドレスを求める
*	(d0.w,d1.w) → a0 = adr
*
*******************************************************************
gramadr:
	movem.l	d0-d1,-(sp)

	movea.w	d0,a0		*
	adda.w	d0,a0		*a0 = x*2

	moveq.l	#GSFTCTR,d0	*
	ext.l	d1		*
	asl.l	d0,d1		*d1 = y*1024 (or y*2048)
	adda.l	d1,a0		*a0 = (x,y)と(0,0)のG-RAMアドレスの差

	adda.l	gbase(pc),a0	*a0 = (x,y)のG-RAMアドレス

	movem.l	(sp)+,d0-d1
	rts
*******************************************************************
*
*	設定されている描画ページからアドレスを算出する
*
*******************************************************************
set_apage:
	move.w	#-1,d1		* ＧＲＡＭのアドレスを算出
	IOCS	_APAGE
	lsl.w	#19-16,d0	*ページ番号を
	swap.w	d0		*  $80000倍する
	clr.w	d0		*
	addi.l	#GPAGE0,d0	*G-RAMの先頭アドレスを足す
	move.l	d0,gbase	*ワークにしまう

	rts


*******************************************************************
*
*	クリッピングウィンドウの設定
*
*******************************************************************
_setcliprect:
ARGPTR	=	8
	link	a6,#0
	movem.l	d1-d4,-(sp)

	movea.l	ARGPTR(a6),a1	*a1=引数
	movem.w	(a1),d1-d4	*d1〜d4に座標を取り出し
	IOCS	_WINDOW		*　IOCSに伝える
	tst.l	d0		*エラーなら
	bmi	retn		*　抜ける

	movem.w	d1-d4,cliprect	*クリッピングウィンドウの
				*　座標を覚えておく
	move.w	#$8000,d0	*$8000のゲタを履かせて
	add.w	d0,d1		*
	add.w	d0,d2		*
	add.w	d0,d3		*
	add.w	d0,d4		*
	movem.w	d1-d4,ucliprect	*　別に覚えておく

	moveq.l	#0,d0		*正常終了
retn:	movem.l	(sp)+,d1-d4
	unlk	a6
	rts
	
*
*		ワークエリア
*
	.data
	.even

read_rot:
	.dc.l	r_TEXT1			* ＶＲＡＭ読み込みルーチンのアドレス

write_rot:
	.dc.l	w_TEXT1			* ＶＲＡＭ書き込みルーチンのアドレス



w_ContReg_mode:				* ポート＃１は２バイトひとかたまりでアクセス
	.dc.w	0			* するので、１バイト目か２バイト目かの区別を
					* するためのもの
					* ０・・１バイト目
					* １・・２バイト目
first_bite:				* １バイト目にどんな値が書き込まれたのかが
	.dc.b	0			* 入っている

	.even

*	ＳＣＲＥＥＮ０，２，４で使う
rewrite0_f_all	.dc.l	0		* rewrite0_f_0〜8すべての or をとったもの
rewrite0_f_0	.dc.l	0
rewrite0_f_1	.dc.l	0
rewrite0_f_2	.dc.l	0
rewrite0_f_3	.dc.l	0
rewrite0_f_4	.dc.l	0
rewrite0_f_5	.dc.l	0
rewrite0_f_6	.dc.l	0
rewrite0_f_7	.dc.l	0

*	これ以下はＳＣＲＥＥＮ２，４で使う
rewrite1_f_all	.dc.l	0		* rewrite1_f_0〜8すべての or をとったもの
rewrite1_f_0	.dc.l	0
rewrite1_f_1	.dc.l	0
rewrite1_f_2	.dc.l	0
rewrite1_f_3	.dc.l	0
rewrite1_f_4	.dc.l	0
rewrite1_f_5	.dc.l	0
rewrite1_f_6	.dc.l	0
rewrite1_f_7	.dc.l	0

rewrite2_f_all	.dc.l	0		* rewrite2_f_0〜8すべての or をとったもの
rewrite2_f_0	.dc.l	0
rewrite2_f_1	.dc.l	0
rewrite2_f_2	.dc.l	0
rewrite2_f_3	.dc.l	0
rewrite2_f_4	.dc.l	0
rewrite2_f_5	.dc.l	0
rewrite2_f_6	.dc.l	0
rewrite2_f_7	.dc.l	0



gbase:	.dc.l	GPAGE0		* ラインルーチン内等で使用

cliprect:
	.dc.w	0		*クリッピング領域
	.dc.w	0		*
	.dc.w	GNPIXEL-1	*
	.dc.w	GNPIXEL-1	*
ucliprect:
	.dc.w	$8000		*クリッピング領域
	.dc.w	$8000		*（$8000のゲタ履き）
	.dc.w	$8000+GNPIXEL-1	*
	.dc.w	$8000+GNPIXEL-1	*


fillptr:
	.dc.w	0
	.dc.w	0
	.dc.w	0
	.dc.w	0
	.dc.w	255		* color

pointptr:
	.dc.w	0
	.dc.w	0
	.dc.w	0		* return color code

	.even

filebuf:
	.ds.b	53 

errmesf:
	.dc.b	"ファイルエラーです",$0d,$0a,$00
errmes:
	.dc.b	"メモリが確保できません",$0d,$0a,$00

	.end

