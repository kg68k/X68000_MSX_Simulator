*
*	Ｍｓｘ Ｓｉｍｕｌａｔｅｒ
*
*		[[[ Ｒ８００ Ｓｉｍｕｌａｔｅｒ ]]]		
*			ＭＣ６８０３０以降専用バージョン
*
*				2024.7.28		by Kuni.
*

; フラグ処理
;
; # 現在の問題点
; * フラグの処理が複雑で、どこでどのフラグをどう処理しているかがわかりにくい
; * フラグの処理が複雑なため、バグが発生しやすい
; * 未定義フラグ(F5,F3)の処理がきちんと実装されていない
;
; # 方針
; ## 遅延評価の見直し
; 今の実装は、フラグの値を毎回計算せずに、必要なタイミングで計算するという遅延評価を行っている。
; ただ、その処理が分散して書かれているため、一箇所にまとめるようにしたい。
; また、当初ちゃんと考えていなかったハーフキャリーフラグの処理や未定義フラグの処理を後から
; 追加したせいで見通しが悪くなっている問題もあるので、それらも見直す。
; ## Z80のフラグの仕様を理解する
; まず、Fレジスタは pop AF を使えば任意の組み合わせをロードすることができるので、
; それは維持する必要がある。
; 次に、add a,b などの基本的な命令を実行しただけで、以下のようにフラグに影響が出る。
; * Sフラグ: 結果が負の場合に1
; * Zフラグ: 結果が0の場合に1
; * Hフラグ: 下位4ビットでのキャリーが発生した場合に1
; * PVフラグ: add/subの場合はオーバーフローフラグとして機能する
; * Nフラグ: 1 (addの場合は1、subの場合は0)
; * Cフラグ: 上位8ビットでのキャリーが発生した場合に1
; これらをいちいち毎回計算するのはコストが大きい。特に論理演算命令後にPVフラグがパリティとして
; 動く場合、、結果のパリティを判定するためにループを回す必要があるなど負荷が高いが、
; 実際に使われるタイミングは限られる(push AF, JP PO, JP PEなど)。
; そのため、演算結果を保持しておく領域を作り、フラグの再計算が必要であることを示すダーティフラグを使い、
; フラグの値を必要な時に再計算するようにする。
; 今までは、演算結果を保存しておき、あとでS,Zを判定するということをやっていたが、Cフラグや、Hフラグのことも
; 考えると情報量が足りないので、以下のように戦略を変更する。
;
; ## フラグを遅延評価するための仕組み
; まず、Fフラグの各ビットに対応するダーティビットを8ビット用意する。このビットが0のフラグに関しては、
; フラグレジスタ(d6)に保存されている値をそのまま使う。このビットが1のフラグに関しては、以下の情報から
; フラグの値を再計算する。
; * 1. 演算対象の2つの8ビットの数値
; * 2. 演算前のキャリーの値
;     * 実際のキャリーフラグの値ではなく、計算に使用したキャリーの値なので、add a,b の場合はキャリーは0になる
;     * 16ビット演算の場合は、下位8bitと上位8bitの計算に分解するようにアルゴリズムを変更し、下位の演算の結果
;       出てきたキャリーの値をここに入れておく
; * 3. 演算結果の8ビットの数値
; * 4. 論理演算か算術演算か
;     * 論理演算ならPVはパリティとして計算し、算術演算ならオーバーフローとして計算する
; * 5. 加算か減算か
;     * 算術演算だった場合
; これらの情報が残っていれば、以下のようにしてフラグの再計算が行える(例外ケースは後述)
;
; * Sフラグ
;     * 演算結果の最上位ビットがSフラグの値
; * Zフラグ
;     * 演算結果が0ならZフラグは1
; * Hフラグ
;     * 算術演算の場合は、もう一度演算を行って、下位4ビットでのキャリーが発生した場合に1にする
;     * 論理演算の場合は、演算の種類によって固定値が入るので、その場合はダーティビットを立てずに直接値をセット
; * PVフラグ
;     * 算術演算の場合は、もう一度演算を行って、オーバーフローが発生するかどうかを判定する
;     * 論理演算の場合は、演算結果のパリティを再計算する
; * Nフラグ
;     * 加算の場合は0、減算の場合は1
; * Cフラグ
;     * 算術演算の場合は、もう一度演算を行ってキャリーが発生した場合に1にする
; * F5, F3フラグ
;     * 未定義フラグは、多くの場合、演算結果のbit5と bit3がそのまま反映されるようなので、そのようにする
;     * 該当しないケースは後述
;
; これではフォローできない例外ケースは以下のように対処する
;
; ### Fレジスタへの直接セット
; pop AF で直接Fレジスタに値をセットすることができるが、この場合は、ダーティビットを立てることなく、
; その値をそのままFレジスタにセットすればよい
;
; ### 16ビット演算の場合
; Z80は16ビット演算を8ビット2回の演算で行っているため、ほとんどのフラグは、後半で行われる上位8ビットの
; 演算に使用した値を上記フィールドに残しておけば対応できる。
; ただ、たとえばZフラグは16ビット全体が0だった場合に1になるため、上位8ビットの結果だけでは判定できない。
; こういったケースは、「その他の例外ケース」同様、直接Fレジスタに値をセットすることで対応する。
;
; ### その他の例外ケース
; 通常の演算では S=1, Z=1 という状態を作ることができないが、Z80のFレジスタにはpop AFなどで、直接値を
; ロードすることができるので、このような状態も反映できる必要がある。
; また、命令によっては上記のようなフラグの再計算では対応できないようなフラグ変化を起こすケールがあるので、
; そういった命令の場合は、直接Fレジスタに値をセットすることで対応する。
; 例えば、INC A でAレジスタの値をインクリメントする命令は、S,Z,H,Nフラグが変化するが、Cフラグは変化しない
; (つまり、 add 1 とはフラグ変化が異なる)。この場合は、まず、現状のCフラグの状態を再計算によって反映し、
; つぎにSZHNフラグだけダーティビットを立てて、上記再計算用フィールドに値をセットすることで対応する。
; 
; # d6レジスタのマッピング
; d5,d6レジスタの32ビットをフルに使い、以下のように保持する
; * d5
;     * 31-24: 演算第1項目の値	(Aレジスタの値など)
;     * 23-16: 演算第2項目の値	(ADD A,Bなどの場合はBレジスタの値)
;     * 15- 8: (無視、ゴミが入っても良いこととする)
;     *  7- 0: 演算結果の値
; * d6
;     *   18: 加算時=0, 減算時=1
;     *   17: 算術演算=0, 論理演算=1
;     *   16: 演算時のキャリーの値
;     * 15-8: Fレジスタのダーティビット
;     *  7-0: z80のFレジスタの値
;
;	F = 00000000
;	    |||||||+--Cy
;	    ||||||+---N
;           |||||+----PV
;           ||||+-----F3
;           |||+------HC
;           ||+-------F5
;           |+--------Z
;           +---------S


	.cpu 68030

	.include	iocscall.mac
	.include	doscall.mac


	.text
	.even

	.xdef	eval_flag_all
	.xdef	eval_flag_SZ
	.xdef	eval_flag_F5F3
	.xdef	eval_flag_HC_C
	.xdef	eval_flag_PV_N

	.xref	registers

eval_flag_all:
	bsr	eval_flag_SZ
	bsr	eval_flag_F5F3
	bsr	eval_flag_HC_C
	bsr	eval_flag_PV_N
	rts

; SとZは同時に評価することが多いので、まとめて行う
eval_flag_SZ:
	; Sフラグの処理
	btst	#7+8,d6		; Sのダーティビットが立っているか
	beq	@f
	btst	#7,d5
	bne	1f
	bclr	#7,d6		; Sフラグをクリア
	bra	@f
1:	bset	#7,d6		; Sフラグをセット
	
@@:	; Zフラグの処理
	btst	#6+8,d6		; Zのダーティビットが立っているか
	beq	@f
	cmp.b	#0,d5		; 演算結果が0か
	beq	1f
	bclr	#6,d6		; Zフラグをクリア
	bra	@f
1:	bset	#6,d6		; Zフラグをセット

@@:	; ダーティビットをクリア
	andi.w	#%00111111_11111111,d6
	rts

; F5とF3は同時に評価することが多いので、まとめて行う
eval_flag_F5F3:
	move.w  d6,d1
	lsr.w	#8,d1		; ダーティビットを取り出す
	andi.w	#%00101000,d1	; F5,F3のダーティビットの値を取り出す
	beq	@f		; 両方0なら何もしない
	move.b	d5,d0		; 最後の演算結果を取り出す
	and.b	d1,d0		; 演算結果のb5とb3のうち、ダーティが立っている場所だけ取り出す
	eor.b	#%11111111,d1	; F5,F3のダーティビットを反転させる
	and.b	d1,d6		; F5,F3のダーティビットの立っていたビットをクリア
	or.b	d0,d6		; F5,F3のダーティビットをセット
	andi.w	#%11010111_11111111,d6	; F5,F3のダーティビットをクリア
 @@:	rts

; キャリー、ハーフキャリーフラグの再評価
eval_flag_HC_C:
	move.w  d6,d3
	lsr.w	#8,d3		; ダーティビットを取り出す
	andi.w	#%00010001,d3	; HC,Cのダーティビットの値を取り出す
	beq	@f		; 両方0なら何もしない
	;
	move.l	d5,d0
	swap	d0		
	move.w  d0,d1		
	andi.w	#$00ff		; 第2項を取り出す
	lsr.w	#8,d0		; 第1項を取り出す
	move.w	d0,d2		; 計算対象である第1項をd2にセット
	btst	#18,d6		; 加算か減算か
	bne	8f
	; 加算の場合
	and.b	#%11101111,ccr	; Xフラグをクリア
	btst	#16,d6		; キャリーがあるか
	beq	1f
	or.b	#%00010000,ccr	; Xフラグをセット
1:	addx.w	d1,d2		; 第1項+第2項+X => d2 (ワードで計算することに注意)
	bra	9f

8:	; 減算の場合
	and.b	#%11101111,ccr	; Xフラグをクリア
	btst	#16,d6		; キャリーがあるか
	beq	1f
	or.b	#%00010000,ccr	; Xフラグをセット
1:	subx.w	d1,d2		; 第1項-第2項-X => d2 (ワードで計算することに注意)

9:	; 演算結果に対し、第1項と第2項のxorを取ると、各ビット位置でキャリーが発生したかどうかがわかる
	; →あるビットに着目すると、
	;   - 演算結果が0なのに、第1項と第2項のどちらか片方だけが1の場合は、キャリーが発生している
	;   - 演算結果が1なのに、第1項と第2項の両方とも0、もしくは両方とも1の場合は、キャリーが発生している
	; ということになるので、3つのxorを取って1だったビットは、キャリーが発生していることになる
	eor.b	d0,d2		; 第1項のxorを取る
	eor.b	d1,d2		; 第2項のxorを取る
	move.b	d2,d0		; 結果をd0にコピー
	and.b	#%00010000,d0	; HCの結果だけ取り出す
	lsr.b	#8,d2		; bit8にキャリーの結果が入っているので bit0に持ってくる
	and.b	#%00000001,d2	; Cの結果だけ取り出す
	or.b	d2,d0		; HC,Cの結果を合成

	and.b	d3,d0		; HC,Cの結果のうち、ダーティが立っているものだけ取り出す
	eor.b	#%11111111,d1	; HC,Cのダーティビットを反転させる
	and.b	d1,d6		; HC,Cのダーティビットの立っていたビットをクリア
	or.b	d0,d6		; HC,Cのダーティビットをセット

	; HC、Cフラグのダーティビットをクリア
	andi.w	#%11101110_11111111,d6

@@:	rts

; PV, Nフラグの再評価
eval_flag_PV_N:
	; Nフラグは通常はダーティビットを立てずに直接セットするが、もしダーティビットが立っていた場合は入れ直す
	btst	#1+8,d6		; Nのダーティビットが立っているか
	beq	@f
	; NダーティビットとN自体をクリア
	andi.w	#%11111101_11111101,d6
	btst	#18,d6		; 加算か減算か
	beq	@f
	ori.b	#%00000010,d6	; 減算の場合はNフラグをセット

@@:	; PVフラグの処理
	btst	#2+8,d6		; PVのダーティビットが立っているか
	beq	@f
	; PVダーティビットとPV自体をクリア
	andi.w	#%11111011_11111011,d6
	btst	#17,d6		; 算術演算か論理演算か
	beq	9f
	; 算術演算の場合は、もう一度演算を行って、オーバーフローが発生するかどうかを判定する

	move.l	d5,d0
	swap	d0		
	move.w  d0,d1		
	andi.w	#$00ff		; 第2項を取り出す
	lsr.w	#8,d0		; 第1項を取り出す
	btst	#18,d6		; 加算か減算か
	bne	8f
	; 加算の場合
	and.b	#%11101111,ccr	; Xフラグをクリア
	btst	#16,d6		; キャリーがあるか(btstではキャリーは変化しない)
	beq	1f
	or.b	#%00010000,ccr	; Xフラグをセット
1:	addx.b	d1,d0		; 第1項+第2項+X => d0 (バイトで計算することに注意)
	bvc	@f		; オーバーフローが発生しなかった場合
	; オーバーフローが発生した場合
	ori.b	#%00000100,d6	; PVフラグをセット
	rts

8:	; 減算の場合
	and.b	#%11101111,ccr	; Xフラグをクリア
	btst	#16,d6		; キャリーがあるか(btstではキャリーは変化しない)
	beq	1f
	or.b	#%00010000,ccr	; Xフラグをセット
1:	subx.b	d1,d0		; 第1項-第2項-X => d0 (バイトで計算することに注意)
	bvc	@f		; オーバーフローが発生しなかった場合
	; オーバーフローが発生した場合
	ori.b	#%00000100,d6	; PVフラグをセット
	rts

9:	; 論理演算の場合
	; d5に残っている演算結果のパリティを計算する
	move.b	d5,d0
	move.b  d0,d1
	lsr.b	#4,d1
	eor.b	d1,d0
	move.b	d0,d1
	lsr.b	#2,d1
	eor.b	d1,d0
	move.b	d0,d1
	lsr.b	#1,d1
	eor.b	d1,d0
	btst.b	#0,d0
	bne	@f		; パリティーが奇数ならPVフラグは0なので何もしない(感覚と逆なので注意)
	ori.b	#%00000100,d6	; パリティーが偶数ならPVフラグをセット
@@:	rts