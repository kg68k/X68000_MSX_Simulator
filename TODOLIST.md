やることリストを列挙しておきます


## CPUエミュレータに、サイクルカウントを実装 (2024/8/17達成済)

エミュレーションが早くなりすぎると、ゲームが早く動きすぎたり、画面描画の重さによって早くなったり遅くなったりと、動きにムラがでてしまいます。
CPUのテストベンチでもサイクルカウントの不一致は無視しているので、ここを正確に実装します。

実装方針は、以下の方法を考えています。

まず、各命令にジャンプテーブルがあるのを利用し、ジャンプテーブルのジャンプ先を以下のようにします。(ワードサイズにしているのは、計算を楽にするため)

```
        .dc.w   4       * サイクル数
        .dc.w   1       * 命令語長
nop:    addq.w  #1,d7
        andi.w  #PAGEADDRMASK,d7
        bne     rts_common
        PC_page_inc
        rts
```

このようにすると、ジャンプ元でジャンプする際に、飛び先アドレスの手前を読み出すことで、その命令のサイクル数と命令語長をあらかじめ取得することができます。
これをインクリメントすることでサイクル数を正確にカウントできるようになります。命令語長の使い道は後述します。

## PCのインクリメント処理と命令後の読み出しの効率化 (2024/8/17達成済)

今の実装は、各命令の処理ルーチンにジャンプした後に、それぞれの命令の中でPCをインクリメントしているので、同じような処理が数百個散らばっていて、ソースがごちゃっとしているという問題があります。また、命令語の長さが先にわかると、複数バイトに渡る命令を一気に読み出しておくことも可能になり、高速化も見込めます。


## MEGA-ROMのサポート

メガロムをサポートしないと大容量のゲームが動かせないのでサポートしたいです。メガロムは8Kバイト単位でバンク切り替えが可能なのですが、今のCPUエミュレータは、Z80の64Kバイトのメモリ空間を16Kバイトごとに分割し、その領域内は連続したメモリ上に配置されていることを前提に作ってしまったので修正が必要です。

上記サイクル長と命令語長のリファクタリングを実施する際に、その分割単位も変更できるようにします。

## スロット切り替え機構の作り直し

メガロムサポートのタイミングで、スロット切り替え機構を見直したい。

現在は、基本4スロットx拡張4スロットx4ページの合わせて64ページに対し、それぞれに配置されている16Kバイトのメモリ領域へのポインタを持っていて、スロット切り替えやPCの教会またぎの際にそれらのポインタを直接コピーしています。

まず、責任境界として、

    * 基本4スロットx拡張4スロットx4ページの切り替えは、memmap モジュールが担当
	* メガロムなど、スロット内部でのバンク切り替えは、各スロットのドライバが担当

とします。read/writeを完全に関数化してしまえばこれは割と容易に達成できるのですが、MS.Xでは、CPUコアがPCから命令フェッチする際はメモリ配列を直接アクセスしており、現状では16KB単位野メモリが連続した領域に存在することが前提になっています。（命令フェッチ以外のたとえば LD A,(HL) などの命令は、memmapモジュールを通じてアクセスしているので、そこは問題ないです）

たとえば、極端な話として読むたびに値が変わるようなスロットがあったとしても、命令フェッチ部分は対応できないということになります。そこを変えようと思うと、CPUコアの命令フェッチ部分をすべて書き換える必要があり、パフォーマンス上もよくないので、このままでいいかなと思っています。実際、プログラムコードが配置されたメモリ領域でそこまでドラスティックに内容が変化することはないとおもいます。

一方で、スロット内で16KBより小さい単位(8Kバイト単位)でのバンク切り替えができるメガロムには対応しないといけないので、CPUコアを最低限そこには対応させる必要があります。

まず、PCが16KBの境界をまたぐ際にポインタの操作を行なっている部分を、8Kバイト単位で行うようにします。PCが8Kページ境界を跨いだら、memmapモジュールから、次の8Kページのポインタを取得し、ポインタを切り替えます。ただだ、これだけだと、メガロムでPCが指しているページそのものを切り替えるケース(たぶんある)にうまく対応できないので、外部からの呼び出して、ポインタを再読み込みできるような仕組みを作ります。

次に、今のmemmapモジュールは 16Kバイト単位でメモリを確保することを前提としてしまっていて、「8バイトのヘッダ+16Kバイトのメモリ領域」という構造にしてしまっているのを変更します。今の作りだと、たとえば32KBのROMイメージを連続して読み込んで、それを2ページにまたがって配置することができず、いちいち16Kバイト単位で分割しないといけない不便さがあります。特にメガロムなどで数百KBのROMイメージを扱う際には、この制約があると扱いにくいため、修正します。

### メモリマップドライバ

MSXには通常のROM、メインメモリ、メガロムなど、様々な種類のデバイスがメモリ上に配置されますが、それらを純難に管理するためにドライバ機構を導入します。
ドライバは以下のような構造をしています。これはオブジェクト指向言語でいうところのクラスに相当します。

```C
typedef struct ms_memmap_driver {
	// 本ドライバインスタンスを解放する場合に呼び出します
	void (*deinit)(ms_memmap_driver_t* driver);
	// memmapモジュールが本ドライバをアタッチした際に呼び出します
	int (*did_attach)(ms_memmap_driver_t* driver);
	// memmapモジュールが本ドライバをデタッチする際に呼び出します
	int (*will_detach)(ms_memmap_driver_t* driver);
	// メモリマッパーセグメント選択レジスタ(port FCh,FDh,FEh,FFh) の値が変更された際に呼び出します
	void (*did_update_memory_mapper)(ms_memmap_driver_t* driver, int slot, uint8_t segment_num);
	// 8ビットの読み出し処理
	uint8_t (*read8)(ms_memmap_driver_t* memmap, uint16_t addr);
	// 16ビットの読み出し処理
	uint16_t (*read16)(ms_memmap_driver_t* memmap, uint16_t addr);
	// 8ビットの書き込み処理
	void (*write8)(ms_memmap_driver_t* memmap, uint16_t addr, uint8_t data);
	// 16ビットの書き込み処理
	void (*write16)(ms_memmap_driver_t* memmap, uint16_t addr, uint16_t data);

	// これを管理している memmap への参照
	ms_memmap_t* memmap;
	// 64Kバイト空間を8Kバイト単位で区切ったポインタの配列
	// このドライバが対応しているページのポインタのみセットされており、それ以外はNULLが入ります
	// 動作中にポインタの値を書き換えた場合は、memmap->update_page_pointer(attached_slot, page_num)を呼び出してください
	uint8_t* page8k_pointers[8];
	// 配置されたスロット情報へのポインタ。1つのドライバインスタンスが、複数のスロットにまたがって配置されることはありません
	ms_memmap_slot_t* attached_slot;
	// buffer (各ドライバが使用するバッファ領域)
	uint8_t* buffer;

} ms_memmap_driver_t;
```

これは以下のようにして拡張(継承)することができます。

```C
// 構造体を拡張し、プロパティを追加する
typedef struct ms_memmap_driver_MEGAROM_8K {
	ms_memmap_driver_t base;
	// extended properties
	int bank_size;
	int selected_bank[4];	// SLOT1前半、SLOT1後半、SLOT2前半、SLOT2後半の4つのバンクの選択状態
} ms_memmap_driver_MEGAROM_8K_t;
```

インスタンスの確保(alloc)と初期化(init)は、各ドライバごとに用意されているグローバル関数によって行います。これは、memmapモジュールがROMイメージを読み込む際に行われます。

```C
	ms_memmap_driver_MEGAROM_8K_t megarom_8k = ms_memmap_MEGAROM_8K_init(ms_memmap_shared, crt_buff, crt_length);
	if( megarom_8k == NULL) {
		printf("MEGAROMの初期化に失敗しました\n");
		return;
	}
```

確保されたインスタンス（構造体）は memmap に登録/解除されます。その際、登録後に did_attachメソッドが呼ばれ、解除直前に will_detachメソッドが呼び出されますので、必要に応じで初期設定や終了処理を差し込むことが可能です。


今はまだ仕組みがないですが、動的に解除する際は memmap から、will_detachメソッドが呼び出され、その後、deinitで解放されます。

```C
	if( megarom_8k->base.will_deattach(megarom_8k, slot) != 0) {
		printf("MEGAROMのデタッチに失敗しました\n");
		return;
	}
	megarom_8k->base.deinit(megarom_8k);
```


## FDDのサポート

MSX2のゲームの多くはFD媒体のものが多いので、FDDエミュレーションも実施したいです。エミュレーション方法はいくつかアイディアがあります。

### OpenMSX方式

MSXはメーカーによって使用しているフロッピーディスクコントローラ(FDC)が全く違うのですが、その違いをFDCのBIOS ROM (DISK BIOS) で吸収しています。たとえば、Panasonic系などで使われているのは TC8566AF というFDCなのですが、以下の記事にあるように、この TC8566AF のI/Oをエミュレーションし、該当する実機からDISK BIOS ROMを抽出してくる、という方法です。

https://qiita.com/suzukiplan/items/2f9d6f29e1a6fc37cf4a

### BIOSレベル (APIレベル) でのエミュレーション

上記方法だと該当する実機のROMの抽出が必要になってしまうので、もう少し上位のレイヤーでフックする方法も検討しています。DISK BIOSに必要なAPIは、以下のサイトによると、

https://www.msx.org/wiki/Disk-ROM_BIOS

* Disk Driver table
	* 4010H (DISKIO) (See PHYDIO in main BIOS)
	* 4013H (DSKCHG)
	* 4016H (GETDPB)
	* 4019H (CHOICE)
	* 401CH (DSKFMT)
	* 401FH (DSKSTP)
* Kernel table
	* 4022H (BASENT)
	* 4025H (FORMTM)
	* 4026H (FORMTM)
	* 4029H (MTOFF)
	* 402DH (GETSLT)
	* 4030H

とのことなので、そんなに多くはありません。これらを独自に実装したDISK BIOS ROMを実装し、適当な I/Oポートを通じてホスト側と通信すればエミュレーションできます。

どちらの方法も一長一短なのですが、後者はZ80のコードをちょと書かないといけないのと、DISK BIOSのことをよくわかっていないところもあるので、まずは前者からかなぁと思っています。

## 各画面モード、VDPコマンドの実装とチューニングを進める

現状は、ゲームを動かしつつ、未実装なものを少しずつ追加している状況なので、どこかで一気にまとめて実装したいです。

GRAPHIC1はBG画面を使うと効率化できそうなので、必要ならそれもやろうと思っています。一方で、ゲームでよく使われるGRAPHIC2やGRAPHIC3(SCREEEN2、4)はBGだとパターン数が足りなくて実現できないので、グラフィックを使う必要があります。なので無理してGRAPHIC1だけやらなくてもいいかなと思っています。

### SET ADJUSTへの対応

CRTCをうまくいじって、SET ADJUSTに対応できないかな？と思っています。ブラウン管ディスプレイでうまくいったとしても、液晶画面とかだとクリップされてしまってダメかもしれませんが……。

うまくいかない場合は画面サイズを 256+8+8くらいに拡張するか、ですね

### H-SYNC割り込みへの対応

割り込み自体は対応できると思います。スクロールレジスタをいじって画面縦二分割にしているゲームなどであれば動きそうですが、スプライトダブラや、パターンネームテーブルなどのベースアドレスをゴリゴリ変更されても、描画がついていかない可能性が高いです。

この辺りも Kepler X必須になるかな？という感じです。

## スペースマンボウへの対応

正直これを動かすのはかなり大変です。操作せん割り込みの途中でグラフィックモードを切り替える対応とかをやっているらしく、正直なところ、正攻法でエミュレーションしても全く間に合わないです。専用にチューニングすればできなくもないかもですが、後述する 「Kepler X 必須」でもいいかなと思います。

## PSGのエンベロープの真面目な実装

できる範囲でやってみようかなと思っています。

## Kepler X との協調動作

Kepler XのFPGAを書き換えて、MS.Xの動作を補助することも考えています。具体的には以下のようなことを考えています。

* VDP
    * 1-Chip MSX用に作った自作の V9938コア(ESE-VDP)をKepler X上に実装します
    * 画面出力は Kepler Xの DVI端子から出力します
* PSG
    * PSGのHDL実装を載せるか、Mercury UnitのSSGを使う方法で実現します
* YM2413
    * DSA (Digital Sound Antiques)さんの [vm2413](https://github.com/digital-sound-antiques/vm2413/blob/master/README_ja.md) を Kepler X上に実装することで FM音源をサポートします
* Z80
    * 現状だと、Phantom Xなどがないと遅くてエミュレーションが間に合わないですが、適当なZ80コアを持ってきてエミュレーションしてもいいかなと思っています
    * その場合、Kepler X上でVDPなどのペリフェラルまで完結させる(1-Chip MSXが Kepler X上に乗ったようなイメージ)ではなく、CPUとペリフェラルの組み合わせを自由に選べるようにしたいです
        * たとえば、「Z80はKepler X上で動かし、VDPは68000側のソフト実装を使う」みたいな
    * その場合 I/O（例えば画面書き換え）がリアルタイムに行えない場合にウエイトを入れる必要がでてきますが、そうするとその分だけCPUの処理数が減ってしまうので、単純に3.58MHzで動かしたのではダメかもしれません
    * たとえばCPUはもう少し早い速度で動かし、サイクル数をカウントしながら、1/60秒ごとにウエイトを入れて全体のサイクル数を調整するなども考えないと難しいかもしれません