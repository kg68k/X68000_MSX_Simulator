やることリストを列挙しておきます


## CPUエミュレータに、サイクルカウントを実装

エミュレーションが早くなりすぎると、ゲームが早く動きすぎたり、画面描画の重さによって早くなったり遅くなったりと、動きにムラがでてしまいます。
CPUのテストベンチでもサイクルカウントの不一致は無視しているので、ここを正確に実装します。

実装方針は、以下の方法を考えています。

まず、各命令にジャンプテーブルがあるのを利用し、ジャンプテーブルのジャンプ先を以下のようにします。(ワードサイズにしているのは、計算を楽にするため)

```
        .dc.w   4       * サイクル数
        .dc.w   1       * 命令語長
nop:    addq.w  #1,d7
        andi.w  #PAGEADDRMASK,d7
        bne     rts_common
        PC_page_inc
        rts
```

このようにすると、ジャンプ元でジャンプする際に、飛び先アドレスの手前を読み出すことで、その命令のサイクル数と命令語長をあらかじめ取得することができます。
これをインクリメントすることでサイクル数を正確にカウントできるようになります。命令語長の使い道は後述します。

## PCのインクリメント処理と命令後の読み出しの効率化

今の実装は、各命令の処理ルーチンにジャンプした後に、それぞれの命令の中でPCをインクリメントしているので、同じような処理が数百個散らばっていて、ソースがごちゃっとしているという問題があります。また、命令語の長さが先にわかると、複数バイトに渡る命令を一気に読み出しておくことも可能になり、高速化も見込めます。


## MEGA-ROMのサポート

メガロムをサポートしないと大容量のゲームが動かせないのでサポートしたいです。メガロムは8Kバイト単位でバンク切り替えが可能なのですが、今のCPUエミュレータは、Z80の64Kバイトのメモリ空間を16Kバイトごとに分割し、その領域内は連続したメモリ上に配置されていることを前提に作ってしまったので修正が必要です。

上記サイクル長と命令語長のリファクタリングを実施する際に、その分割単位も変更できるようにします。

## FDDのサポート

MSX2のゲームの多くはFD媒体のものが多いので、FDDエミュレーションも実施したいです。エミュレーション方法はいくつかアイディアがあります。

### OpenMSX方式

MSXはメーカーによって使用しているフロッピーディスクコントローラ(FDC)が全く違うのですが、その違いをFDCのBIOS ROM (DISK BIOS) で吸収しています。たとえば、Panasonic系などで使われているのは TC8566AF というFDCなのですが、以下の記事にあるように、この TC8566AF のI/Oをエミュレーションし、該当する実機からDISK BIOS ROMを抽出してくる、という方法です。

https://qiita.com/suzukiplan/items/2f9d6f29e1a6fc37cf4a

### BIOSレベル (APIレベル) でのエミュレーション

上記方法だと該当する実機のROMの抽出が必要になってしまうので、もう少し上位のレイヤーでフックする方法も検討しています。DISK BIOSに必要なAPIは、以下のサイトによると、

https://www.msx.org/wiki/Disk-ROM_BIOS

* Disk Driver table
	* 4010H (DISKIO) (See PHYDIO in main BIOS)
	* 4013H (DSKCHG)
	* 4016H (GETDPB)
	* 4019H (CHOICE)
	* 401CH (DSKFMT)
	* 401FH (DSKSTP)
* Kernel table
	* 4022H (BASENT)
	* 4025H (FORMTM)
	* 4026H (FORMTM)
	* 4029H (MTOFF)
	* 402DH (GETSLT)
	* 4030H

とのことなので、そんなに多くはありません。これらを独自に実装したDISK BIOS ROMを実装し、適当な I/Oポートを通じてホスト側と通信すればエミュレーションできます。

どちらの方法も一長一短なのですが、後者はZ80のコードをちょと書かないといけないのと、DISK BIOSのことをよくわかっていないところもあるので、まずは前者からかなぁと思っています。

## 各画面モード、VDPコマンドの実装とチューニングを進める

現状は、ゲームを動かしつつ、未実装なものを少しずつ追加している状況なので、どこかで一気にまとめて実装したいです。

GRAPHIC1はBG画面を使うと効率化できそうなので、必要ならそれもやろうと思っています。一方で、ゲームでよく使われるGRAPHIC2やGRAPHIC3(SCREEEN2、4)はBGだとパターン数が足りなくて実現できないので、グラフィックを使う必要があります。なので無理してGRAPHIC1だけやらなくてもいいかなと思っています。

### SET ADJUSTへの対応

CRTCをうまくいじって、SET ADJUSTに対応できないかな？と思っています。ブラウン管ディスプレイでうまくいったとしても、液晶画面とかだとクリップされてしまってダメかもしれませんが……。

うまくいかない場合は画面サイズを 256+8+8くらいに拡張するか、ですね

### H-SYNC割り込みへの対応

割り込み自体は対応できると思います。スクロールレジスタをいじって画面縦二分割にしているゲームなどであれば動きそうですが、スプライトダブラや、パターンネームテーブルなどのベースアドレスをゴリゴリ変更されても、描画がついていかない可能性が高いです。

この辺りも Kepler X必須になるかな？という感じです。

## スペースマンボウへの対応

正直これを動かすのはかなり大変です。操作せん割り込みの途中でグラフィックモードを切り替える対応とかをやっているらしく、正直なところ、正攻法でエミュレーションしても全く間に合わないです。専用にチューニングすればできなくもないかもですが、後述する 「Kepler X 必須」でもいいかなと思います。

## PSGのエンベロープの真面目な実装

できる範囲でやってみようかなと思っています。

## Kepler X との協調動作

Kepler XのFPGAを書き換えて、MS.Xの動作を補助することも考えています。具体的には以下のようなことを考えています。

* VDP
    * 1-Chip MSX用に作った自作の V9938コア(ESE-VDP)をKepler X上に実装します
    * 画面出力は Kepler Xの DVI端子から出力します
* PSG
    * PSGのHDL実装を載せるか、Mercury UnitのSSGを使う方法で実現します
* YM2413
    * DSA (Digital Sound Antiques)さんの [vm2413](https://github.com/digital-sound-antiques/vm2413/blob/master/README_ja.md) を Kepler X上に実装することで FM音源をサポートします
* Z80
    * 現状だと、Phantom Xなどがないと遅くてエミュレーションが間に合わないですが、適当なZ80コアを持ってきてエミュレーションしてもいいかなと思っています
    * その場合、Kepler X上でVDPなどのペリフェラルまで完結させる(1-Chip MSXが Kepler X上に乗ったようなイメージ)ではなく、CPUとペリフェラルの組み合わせを自由に選べるようにしたいです
        * たとえば、「Z80はKepler X上で動かし、VDPは68000側のソフト実装を使う」みたいな
    * その場合 I/O（例えば画面書き換え）がリアルタイムに行えない場合にウエイトを入れる必要がでてきますが、そうするとその分だけCPUの処理数が減ってしまうので、単純に3.58MHzで動かしたのではダメかもしれません
    * たとえばCPUはもう少し早い速度で動かし、サイクル数をカウントしながら、1/60秒ごとにウエイトを入れて全体のサイクル数を調整するなども考えないと難しいかもしれません