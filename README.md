# About MS.X

This is MSX Simulator working on the X68000 series computers. I made it when I was teenager and it is just my study, so it is not completed.

But I decided to make it public for my memorial.

# Architecture (in Japanese)

## ゴール

完全なエミュレーションは不可能と考えているため、MSXの簡単なゲームやプログラムの動作確認ができる程度を目指しています。
MSXのコアな機能をフル活用したメガデモなどが動作することは目標としていません。

## CPUエミュレーション

自作の Z80 (R800) エミュレーターを使っています。フルアセンブラで書かれています。

基本的にはループをぐるぐる回してZ80の命令を逐一解釈して実行しているだけですが、Z80の割り込み処理や、X68000側のキー入力の対応など、定期的にループ処理を中断できるようになっています。
ループ処理の中断は emu_yield を1にセットすることで行われます。例えば以下のようなときに1になります。

* Z80の割り込み発生時
	* 垂直同期割り込み
	* 捜査線割り込み(将来対応)
* X68000側のキーボード入力を検知したとき

emu_yeildによってエミュレーションループが中断すると、まずZ80のステータスレジスタを見て、Z80の割り込みによるものかどうかを調べます（MSXではZ80の割り込みはVDPによるもの(垂直同期割り込みと捜査線割り込み)しかありません）。Z80の割り込みだった場合は、Z80の割り込み処理を行い、エミュレーションループに戻ります。

中断要因がX68000側のキーボード入力だった場合は、C言語側のルーチンに制御を戻し、X68000 のIOCS BITSNSを使ってキーマトリクスを読み取り、MSXのキーマトリクスに変換してZ80のメモリに直接書き込みます。MSXのPPI 8255AのI/Oをエミュレーションしているわけではないですが、問題がある場合は PPIのエミュレーションをするようにしてもいいかもしれません。

## VDPエミュレーション

MSXの画面を X68000の画面に描画するため、以下のような構成にしています。

* MSXのスプライト
	* X68000のスプライト機能を使って描画
* MSXのグラフィック/テキスト
	* X68000のグラフィック機能を使って描画
* MSXのバックドロップ(裏に透けて見える色)
	* X68000のBGプレーンを使って描画

MSXの解像度はインターレースモードを含めると 最大512x424なので、これを X68000の 512x512の画面上に描画します。また、MSXの水平同期周波数は15kHzですが、X68000では31kHzの画面を出力しています。

MSXの画面モードの多くは15kHz、横256ドットなので、X68000の画面も15kHz、256ドットモードにした方がより実機に近づき、パフォーマンス上も有利かもしれませんがですが、今のところは31kHz、512ドットモードで描画することにしています。

これは、以下のような理由でそうしています。

* X68000を 31kHz専用ディスプレイ(液晶など)で使っている人も多く 15kHzに切り替わると映らないケースも多い
* 512ドットモードの方が、db.xでデバッグしやすい（文字が大きくなりすぎない）
* MSXは横512ドットモードの時でもスプライトは常に横256ドットの解像度で表示される。そのため、MSXの解像度に合わせてX68000の画面モードを変化させると、スプライト描画の処理が複雑になる

## スプライトエミュレーション

スプライトは、X68000のスプライトを使って実現します。

MSXのスプライトの仕様は以下の通りです。

* サイズ
	* 8x8 or 16x16
	* 2倍に拡大するモードもある
* パターン
	* 1パターンにつき 1色
	* スプライトモード2では重ね合わせで多色化も可能
* 横に並べられるスプライト数
	* モード1(MSX1) 4個
	* モード2(MSX2) 8個
* 登録できるパターン数
	* 8x8換算で、256個
* 同時に表示できる数
	* 32個

一方、X68000のスプライトは以下の通りです。

* サイズ
	* 16x16
* パターン
	* 1パターンにつき 16色
* 横に並べられるスプライト数
	* 32個
* 登録できるパターン数
	* 16x16で、128個
* 同時に表示できる数
	* 128個

ですが、X68000側の解像度は512x512なので、MSXのスプライトの1ドットは、X68000では2ドットになります。つまり以下のようになります。

* MSXの 8x8ドットモード、拡大なしの場合
	* 1スプライトを 16x16ドットで描画する
	* MSXは同時に32個表示できるが、X68000は16x16を128個表示できるので問題ない
	* 横に最大 32個並べることができてしまう
		* 同じスプライトを4つずつ重ねて表示することで、横8個の制限を再現することは可能
		* 同じスプライトを8個重ねれば横4個の制限も可能だが、8 x 32で 256個表示する必要があるので、スプライトダブラが必要になる
	* MSXは8x8の定義を256個作ることができるが、X68000のスプライトは16x16の定義を128個しか登録できない
* MSXの 16x16ドットモード、拡大なしの場合
	* 1スプライトを 16x16ドットを2x2個ずつ 4つ並べ、32x32ドットで描画する
	* MSXは同時に32個表示できるが、X68000は32x32を32個表示できるので問題ない
	* 横に最大 16個並べることができてしまう
		* 同時表示32個でギリギリなので、同じスプライトを重ねて表示することによる横4個 or 横8個の制限を再現することは難しい(スプライトダブラが必要)
	* MSXは16x16の定義を64個作ることができるが、X68000のスプライトは32x32の定義を32個しか登録できない
* MSXの 8x8ドットモード、拡大ありの場合
	* 1スプライトを 16x16ドットを2x2個ずつ 4つならべ、32x32ドットで描画する
	* MSXは同時に32個表示できるが、X68000は32x32を32個表示できるので問題ない
	* 横に最大 16個並べることができてしまう
		* 同時表示32個でギリギリなので、同じスプライトを重ねて表示することによる横4個 or 横8個の制限を再現することは難しい(スプライトダブラが必要)
	* MSXは8x8の定義を256個作ることができるが、X68000のスプライトは32x32の定義を32個しか登録できない
* MSXの 16x16ドットモード、拡大ありの場合
	* 1スプライトを 16x16ドットを4x4個ずつ 16個並べ、64x64ドットで描画する
	* MSXは同時に32個表示できるが、X68000は64x64を8個しか表示できないので、スプライトダブラが必要
	* 横に最大 8個並べることができてしまう
		* 同時表示数が足りてないので、同じスプライトを重ねて表示することによる横4個の制限を再現するにはスプライトダブラが必要
	* MSXは16x16の定義を64個作ることができるが、X68000のスプライトは64x64の定義を8個しか登録できない

以上のようになるため、少なくともMSXのスプライトの拡大モードは実現が難しそうです。もし将来拡大モードを実現する場合は、たとえばテキストプレーンに描画するなどの方法を考える必要があります。

そこで、まずは拡大なしの8x8ドットモード、16x16ドットモードのスプライトを実装することにしました。

その場合でも、PCGの定義数が足りないので、以下のようにして実現します。

* MSXは同時に32個しか表示できないので、X68000側は、その表示中の32個の定義だけをPCGに登録する
* X68000側はPCGの128個の定義と SSR(スプライトスクロールレジスタ)を一対一に対応させる
* MSXのスプライト番号と、X68000のPCG、SSR(スプライトスクロールレジスタ)の対比は以下のようにする
	* SP #0
		* PCG #0-#3
		* SSR #0-#3
	* SP #1
		* PCG #4-#7
		* SSR #4-#7
	* SP #31
		* PCG #124-#127
		* SSR #124-#127

こうすると、たとえばMSX側でスプライト番号0のパターンを nに変更した場合は、X68000側ではPCG #0-#3をn番のパターンで書き換えることで実現できます。MSX側で複数のスプライト番号に同じパターンnをセットした場合でも、X68000側はそれぞれのPCGにn番のパターンをセットすることになります(定義が冗長になるが、処理が簡単)。

## PSGエミュレーション

YM2151を使って似たような波形を作って鳴らします。
エンベロープの再現がちょっと大変なので、どうするか悩んでいます。割り込みで音量を調整してエンベロープを再現するしかないかもしれませんが、まずはそれっぽい音階の音が出ることまでを目標にしています。

## FDCエミュレーション

フロッピーディスクのエミュレーションもしたいところですが、おそらくBIOSをハックする必要があるので、すぐには難しいかもしれません。
MSXのC-BIOSのようなものをベースにすればできるかも？